#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/$w
#c# 2019-09-xx <RC
#m# MOAR: OK
#j# JVM:  BROKEN
#n# 67.710u 0.482s 1:07.35
#n# 94.142u 0.528s 1:34.07 # getting $a, etc. via substr was probably more efficient...
#n# Do .race and Perl5 call conflict?

use ntheory:from<Perl5> <:all>;

my @res;

my atomicint @Rare[3];
my atomicint $cnt;

#(flat
for (flat
               1 .. 1000,
         600_000 .. 700_000,
     281_000_000 .. 281_100_000,
) -> $n {
#).race(:8degree, :8batch).map: -> $n {

#   2_022_600_000 .. 2_023_000_000,
# 868_591_000_000 .. 868_592_000_000,

    next unless $n ~~ /^^ <[2468]> /;

    if $n > 1000 {
        my ($a,$b,$p,$q) = ($n ~~ /^^ (.)(.).*(.)(.) $$/)>>.Int;
        next unless    $q == none(1,4,6,9);
        next unless $a-$q ==  any(0,1,4,5,6);

        given $a {
          when 2 { next if $q != 2 or $b != $p }
          when 4 { next unless  $q == 0             and 0 == $b-$p }
          when 6 { next unless ($q == 0 or $q == 5) and 0 != $b-$p }
          when 8 { 
                   next unless $q == any(2,3,7,8);
                  (next unless 9 == $b+$p) if $q == 2;
          }
        }
    }

    next unless $n > my $r = $n.flip;
    next unless is_power($n+$r, 2) and is_power($n-$r, 2);

    # possibly redundant?
    #my $dr = $n;
    #while $dr.chars > 1 { $dr = [+] $dr.comb }
    #next unless $dr == any(2,5,8,9);

say "n: $n";
    @Rare[$cntâš›++] = $n;
}

.say for @Rare;

my $ref = q:to/END/;
65
621770
281089082
END

my $refextra = q:to/END/;
2022652202
2042832002
868591084757
872546974178
872568754178
END

use Test;
is @Rare.join("\n"), chomp $ref;
