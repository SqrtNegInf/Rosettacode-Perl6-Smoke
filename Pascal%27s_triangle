#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Pascal%27s_triangle
#c# 2018-08-20 <RC
#m# MOAR: OK
#j# JVM:  OK

# Works with: rakudo version 2015-10-03
#using a lazy sequence generator[edit]
#The following routine returns a lazy list of lines using the sequence operator (...). With a lazy result you need not tell the routine how many you want; you can just use a slice subscript to get the first N lines:

sub pascal1 {
    [1], { [0, |$_ Z+ |$_, 0] } ... *
}
 
my @res1 = pascal1[^10];

#One problem with the routine above is that it might recalculate the sequence each time you call it. Slightly more idiomatic would be to define the sequence as a lazy constant. Here we use the @ sigil to indicate that the sequence should cache its values for reuse, and use an explicit parameter $prev for variety:

constant @pascal2 = [1], -> $prev { [0, |$prev Z+ |$prev, 0] } ... *;
 
my @res2 = @pascal2[^10];
#Since we use ordinary subscripting, non-positive inputs throw an index-out-of-bounds error.

#recursive[edit]
#Translation of: Haskell
multi sub pascal3 (1) { $[1] }
multi sub pascal3 (Int $n where 2..*) {
    my @rows = pascal3 $n - 1;
    |@rows, [0, |@rows[*-1] Z+ |@rows[*-1], 0 ];
}
 
my @res3 = pascal3 10;
#Non-positive inputs throw a multiple-dispatch error.

#iterative[edit]
#Translation of: Perl
sub pascal4 ($n where $n >= 1) {
   my @out = my @last = [1];
   for 1 .. $n - 1 -> $row {
       #@out.push: @last = 1, |map({ @last[$_] + @last[$_ + 1] }, 0 .. $row - 2), 1;
       @last = 1, |map({ @last[$_] + @last[$_ + 1] }, 0 .. $row - 2), 1;
       @out[$row] = @last;
dd @last;
say '--';
.say for @out; 
say '--';
#sleep 1;
   }
   return @out;
}
 
my @res4 = pascal4 4;
#Non-positive inputs throw a type check error.

#.say for @res4;
exit;

my $ref = q:to/END/;
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1
1 6 15 20 15 6 1
1 7 21 35 35 21 7 1
1 8 28 56 70 56 28 8 1
1 9 36 84 126 126 84 36 9 1
END


use Test;
is @res1.join("\n"), chomp $ref;
is @res2.join("\n"), chomp $ref;
is @res3.join("\n"), chomp $ref;
is @res4.join("\n"), chomp $ref;
