#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/State_name_puzzle
#c# 2015-11-29 <RC, 2018-04-30 >RC
#n# 
#n# an intermittant two-part/two-pass bug related to 'spesh delay'?
#n#
#n# bug source: S/State_name_puzzle
#n#
#n# the actual bug:
#n#   off-by-one for upper end of range '$i ^..^ @s', goes one past end of array IFF in the 'for x..y -> z' context
#n#   this leads to '@pairs' incorrectly containing valid strings being paired with 'Any'
#n#   first seen: Rakudo version 2019.03-39-g23fca8f6f built on MoarVM version 2019.03-31-g6c7810ce7 (approx 2019-03-15)
#n#
#n# conditions required to enable the bug:
#n#   routine 'anastates' is called a 2nd time
#n#   both 'trigger A' and 'trigger B' are active
#n#
#n# conditions that disable the bug:
#n#   if either 'trigger A' or 'trigger B' is disabled (and a corresponding 'work-around' A/B is used)
#n#   MVM_SPESH_NODELAY=1 is set
#n#
#n# additionally:
#n#   the list of 'states' as given enables the bug, adding or deleting a few will 
#n#   sometimes disable the bug (or just make it trigger less frequently?)

my @states = < A B C D E F G H I K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o >;
say 'RUN 1'; .say for my @res1 = anastates @states;
say 'RUN 2'; .say for my @res2 = anastates @states; # problem is always on 2nd call

sub anastates (@s) {
    my @pairs;
    for ^@s -> $i {
	   #for $i ^..  @s.end -> $j {  # work-around A1
	   #for $i ^..^ +@s -> $j {     # work-around A2
 	   #my $range = $i ^..^ @s;     # work-around A3.1
 	   #for $range -> $j {          # work-around A3.2
	    for $i ^..^ @s -> $j {      # trigger A
            die "BUG" if ! defined @s[$j]; # just bail when $j doesn't subscript a valid location in @s
	        @pairs.push: [ @s[$i], @s[$j] ];
	    }
    }

    # this line generates warnings (Use of uninitialized value of type Any in string context) when @pairs contains 'Any')
    my $equivs = hash @pairs.classify: *.lc.comb.sort.join; 

    gather for $equivs.values -> @c {
	for ^@c -> $i {
	   #for $i ^.. @c.end {         # work-around B1
	   #for $i ^..^ +@c {           # work-around B2
	    for $i ^..^ @c {            # trigger B
            # this code not relevant 
	    }
	}
    }
}
