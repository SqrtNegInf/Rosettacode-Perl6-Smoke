#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/State_name_puzzle
#c# 2015-11-29 <RC, 2018-04-30 >RC
#m# MOAR: OK
#j#  JVM: OK
#n# 
#n# a hard-to-reproduce two-pass/two-part bug 
#n# (further complication: it does not trigger on every run of the program)
#n#
#n# the actual bug:
#n#  off-by-one for upper end of range '$i ^..^ @s', goes 1 index past end of array
#n#
#n# conditions required to enable the bug:
#n#   routine 'anastates' is called a 2nd time
#n#   both 'trigger A' and 'trigger B' are active
#n#
#n# conditions that disable the bug:
#n#   if either 'trigger A' or 'trigger B' is disabled (and corresponding 'work-around' A/B is used)
#n#   'work-around C' is used
#n#   MVM_SPESH_NODELAY=1 is set
#n#
#n# addtionally:
#n#   the list of states as given enables the bug, deleting a few will 
#n#   sometimes disable the bug (or just make it trigger less frequently)

my @states = <
    Alabama Alaska Arizona Arkansas California Colorado Connecticut Delaware
    Florida Georgia Hawaii Idaho Illinois Indiana Iowa Kansas Kentucky
    Louisiana Maine Maryland Massachusetts Michigan Minnesota Mississippi
    Missouri Montana Nebraska Nevada New_Hampshire New_Jersey New_Mexico
    New_York North_Carolina North_Dakota Ohio Oklahoma Oregon Pennsylvania
    Rhode_Island South_Carolina South_Dakota Tennessee Texas Utah Vermont
    Virginia Washington West_Virginia Wisconsin Wyoming
>;

my (@res1,@res2);
say 'RUN 1'; .say for @res1 = anastates @states;
say 'RUN 2'; .say for @res2 = anastates @states;

sub anastates (@states) {
    my @s = @states.uniqueÂ».subst('_', ' ');

    my @pairs;
    for ^@s -> $i {
	    #for $i ^..  @s.end -> $j { # work-around A
	    #for $i ^..^ +@s -> $j { # work-around A
        my $range;
	    for ($range = $i ^..^ @s) -> $j {
#	    for $range -> $j { # trigger A
#	    for $i ^..^ @s -> $j { # trigger A
            put "j: $j"; # if not @s[$j].defined;
	        @pairs.push: [ @s[$i], @s[$j] ];
	    }
    }

    my $equivs = hash @pairs.classify: *.lc.comb.sort.join;

    gather for $equivs.values -> @c {
    #my $cnt2 = +@c; # work-around C
	for ^@c -> $i {
	    #for $i ^.. @c.end -> $j { # work-around B
	    #for $i ^..^ +@c -> $j { # work-around B
	    for $i ^..^ @c -> $j {  # trigger B
            # stuff here not relevant to bug
	    }
	}
    }
}

