#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Polyspiral
#t# interactive
#c# 2018-10-19 <RC
#m# MOAR: OK
#j# JVM:  BROKEN

# SDL full animation[edit]
# Uses the same basic algorithm but fully animated. Use the up / down arrow keys to speed up / slow down the update speed. Use PgUp / PgDn keys to increment / decrement animation speed by large amounts. Use left / right arrow keys to reverse the "direction" of angle change. Press Space bar to toggle animation / reset to minimum speed.

use SDL2::Raw;
 
my $width  = 1400;
my $height = 1000;
 
SDL_Init(VIDEO);
 
my $window = SDL_CreateWindow(
    'Polyspiral',
    SDL_WINDOWPOS_CENTERED_MASK,
    SDL_WINDOWPOS_CENTERED_MASK,
    $width, $height,
    OPENGL
);
 
my $render = SDL_CreateRenderer($window, -1, ACCELERATED +| PRESENTVSYNC);
 
my $event = SDL_Event.new;
 
enum KEY_CODES (
    K_UP    => 82,
    K_DOWN  => 81,
    K_LEFT  => 80,
    K_RIGHT => 79,
    K_SPACE => 44,
    K_PGUP  => 75,
    K_PGDN  => 78,
);
 
my $angle = 0;
my $lines = 240;
my @rgb = (^$lines).map: { hsv2rgb(($_ * 360/$lines % 360)/360, 1, 1).list };
my ($x1, $y1);
my $dir = 1;
my $incr = .0001/π;
my $step = $incr*100;
 
main: loop {
    $angle = ($angle + $dir * $step) % τ;
    ($x1, $y1) = $width div 2, $height div 2;
 
    while SDL_PollEvent($event) {
        my $casted_event = SDL_CastEvent($event);
        given $casted_event {
            when *.type == QUIT { last main }
            when *.type == KEYDOWN {
                if KEY_CODES(.scancode) -> $comm {
                    given $comm {
                        when 'K_LEFT'  { $dir = -1 }
                        when 'K_RIGHT' { $dir = 1 }
                        when 'K_UP'    { $step += $incr }
                        when 'K_DOWN'  { if $step > 2*$incr { $step -= $incr } }
                        when 'K_PGUP'  { $step += $incr*50 }
                        when 'K_PGDN'  { $step -= $incr*50; $step = $step < $incr ?? $incr !! $step }
                        when 'K_SPACE' { $step = $step ?? 0 !! $incr }
                    }
                }
            }
        }
    }
 
    for ^$lines {
        my $length = 3 + 3 * $_;
        my ($x2, $y2) = ($x1, $y1) «+« cis($angle * $_).reals »*» $length;
        SDL_SetRenderDrawColor($render, |@rgb[$_], 255);
        SDL_RenderDrawLine($render, |($x1,$y1,$x2,$y2)».round(1));
        ($x1, $y1) = $x2, $y2;
    }
    @rgb.=rotate;
    SDL_RenderPresent($render);
    SDL_SetRenderDrawColor($render, 0, 0, 0, 0);
    SDL_RenderClear($render);
}
 
SDL_Quit();
 
sub hsv2rgb ( $h, $s, $v ){ # inputs normalized 0-1
    my $c = $v * $s;
    my $x = $c * (1 - abs( (($h*6) % 2) - 1 ) );
    my $m = $v - $c;
    my ($r, $g, $b) = do given $h {
        when   0..^(1/6) { $c, $x, 0 }
        when 1/6..^(1/3) { $x, $c, 0 }
        when 1/3..^(1/2) { 0, $c, $x }
        when 1/2..^(2/3) { 0, $x, $c }
        when 2/3..^(5/6) { $x, 0, $c }
        when 5/6..1      { $c, 0, $x }
    }
    ( $r, $g, $b ).map: ((*+$m) * 255).Int
}
