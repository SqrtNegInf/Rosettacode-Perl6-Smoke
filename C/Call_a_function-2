#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Call_a_function
#c# 2019-09-25 NOT ON RC
#m# MOAR: OK
#j# JVM:  OK
#n# entry was by Tim Toady in 2011 (no modifications since)
#n# validated the listed function call syntax (it all works, with some effort)

my (@f0, @i0, @f1, @j1, @l1, @f2, @k2, @m2, @f3, @g3, @h3, @n3);

multi f ()          { state $x;                                    @f0.push: "f0-" ~ ++$x }
multi f ($a)        { state $x; die if 1  != $a;                   @f1.push: "f1-" ~ ++$x }
multi f ($a,$b)     { state $x; die if 3  != $a+$b;                @f2.push: "f2-" ~ ++$x }
multi f (@a)        { state $x; die if @a != [2,3,4];              @f3.push: "f3-" ~ ++$x }
multi f ($a,$b,$c)  { state $x; die if 2  != $a || 4 != $c;        @f3.push: "F3-" ~ ++$x }
sub   g ($a,*@b)    { state $x; die if @b != [2,3,4] || 1 != $a;   @g3.push: "g3-" ~ ++$x }

my \i = ->          { state $x;                                    @i0.push: "i0-" ~ ++$x }
my \l = -> $a       { state $x; die if 1 != $a;                    @l1.push: "l1-" ~ ++$x }
my \m = -> $a,$b    { state $x; die if 1 != $a || 2 != $b;         @m2.push: "m2-" ~ ++$x }
my \n = -> @a       { state $x; die if @a != [2,3,4];              @n3.push: "n3-" ~ ++$x }

Int.^add_method( 'j', method () 
                    { state $x; die if 1 != self;                  @j1.push: "j1-" ~ ++$x } );
Int.^add_method( 'k', method ($a) 
                    { state $x; die if 1 != self || 2 != $a;       @k2.push: "k2-" ~ ++$x } );
Int.^add_method( 'h', method (@a) 
                    { state $x; die if @a != [2,3,4] || 1 != self; @h3.push: "h3-" ~ ++$x } );

my $ref   =  &f;  # soft ref
my $f    :=  &f;  # hard ref
my $g    :=  &g;  # hard ref
my $f-sym = '&f'; # symbolic ref
my $g-sym = '&g'; # symbolic ref
my $j-sym =  'j'; # symbolic ref
my $k-sym =  'k'; # symbolic ref
my $h-sym =  'h'; # symbolic ref

#Calling a function with no arguments:

f;            # 1  as list operator
f();          # 2  as function
i.();         # 3  as function, explicit postfix form  # defined via pointy-block (also see Church_numerals)
#f.();        #x3x as function, explicit postfix form  # would have to preface with '&', hence === #7
$ref();       # 4  as object invocation
$ref.();      # 5  as object invocation, explicit postfix
&f();         # 6  as object invocation
&f.();        # 7  as object invocation, explicit postfix
::($f-sym)(); # 8  as symbolic ref
say join ' ', @f0, @i0;

#Calling a function with exactly one argument:

f 1;          #  1  as list operator
f(1);         #  2  as named function
l.(1);        #  3  as named function, explicit postfix  # defined via pointy-block
#&f.(1);      # x3x as named function, explicit postfix  # ?? had to preface with '&'
$f(1);        #  4  as object invocation (must be hard ref)   
$ref.(1);     #  5  as object invocation, explicit postfix
1.$f;         #  6  as pseudo-method meaning $f(1) (hard ref only)
1.$f();       #  7  as pseudo-method meaning $f(1) (hard ref only)
1.&f;         #  8  as pseudo-method meaning &f(1) (is hard f)
1.&f();       #  9  as pseudo-method meaning &f(1) (is hard f)
1.j;          # 10  as method via dispatcher              # required custom routine, 'Int.^add_method'
1.j();        # 11  as method via dispatcher
1."$j-sym"(); # 12  as method via dispatcher, symbolic
#+1;          #     as operator to prefix:<+> function
say join ' ', @f1, @l1, @j1;

# Calling a function with exactly two arguments:

f 1,2;         #  1  as list operator
f(1,2);        #  2  as named function
m.(1,2);       #  3  as named function, explicit postfix  # defined via pointy-block
#&f.(1,2);     # x3x as named function, explicit postfix  # ?? had to preface with '&'
$ref(1,2);     #  4  as object invocation (must be hard ref)
$ref.(1,2);    #  5  as object invocation, explicit postfix
1.$f: 2;       #  6  as pseudo-method meaning $f(1,2) (hard ref only)
1.$f(2);       #  7  as pseudo-method meaning $f(1,2) (hard ref only)
1.&f: 2;       #  8  as pseudo-method meaning &f(1,2) (is hard f)
1.&f(2);       #  9  as pseudo-method meaning &f(1,2) (is hard f)
1.k: 2;        # 10  as method via dispatcher
1.k(2);        # 11  as method via dispatcher
1."$k-sym"(2); # 12  as method via dispatcher, symbolic
#1 + 2         #     as operator to infix:<+> function
say join ' ', @f2, @k2, @m2;

# Calling a function with a variable number of arguments (varargs):

my @args = 2,3,4;

f @args;           #  1  as list operator
f(@args);          #  2  as named function
n.(@args);         #  3  as named function, explicit postfix  # defined via pointy-block
#&f.(@args);       # x3x as named function, explicit postfix  # ?? had to preface with '&'
$ref(@args);       #  4  as object invocation (must be hard ref)
$ref.(@args);      #  5  as object invocation, explicit postfix
1.$g: @args;       #  6  as pseudo-method meaning $f(1,@args) (hard ref)
1.$g(@args);       #  7  as pseudo-method meaning $f(1,@args) (hard ref)
1.&g: @args;       #  8  as pseudo-method meaning &f(1,@args)
1.&g(@args);       #  9  as pseudo-method meaning &f(1,@args)
1.h: @args;        # 10  as method via dispatcher
1.h(@args);        # 11  as method via dispatcher
1."$h-sym"(@args); # 12  as method via dispatcher, symbolic
#@args X @blargs;  #     as list infix operator to infix:<X>

f(|@args);  # equivalent to f(1,2,3)
say join ' ', @f3, @g3, @h3, @n3;

#say '====='; say (@f0, @i0, @f1, @j1, @l1, @f2, @k2, @m2, @f3, @g3, @h3, @n3).join("\n"); exit;

my $reference = qq:to/END/;
f0-1 f0-2 f0-3 f0-4 f0-5 f0-6 f0-7
i0-1
f1-1 f1-2 f1-3 f1-4 f1-5 f1-6 f1-7 f1-8
j1-1 j1-2 j1-3
l1-1
f2-1 f2-2 f2-3 f2-4 f2-5 f2-6 f2-7 f2-8
k2-1 k2-2 k2-3
m2-1
f3-1 f3-2 f3-3 f3-4 F3-1
g3-1 g3-2 g3-3 g3-4
h3-1 h3-2 h3-3
n3-1
END

use Test;
is (@f0, @i0, @f1, @j1, @l1, @f2, @k2, @m2, @f3, @g3, @h3, @n3).join("\n"), chomp $reference;
