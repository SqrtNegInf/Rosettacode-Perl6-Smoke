#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Checksumcolor
#c# 2019-04-20 <RC
#m# MOAR: OK
#j# JVM:  OK
#f# RC file: checksumcolor.html
#n# by using $*OUT, 'say' can be left alone (only 'print' needs the explicit handle)
#n# default input created with: 
#n#   md5 -r ref/test/*txt > ref/checksumcolor.dat

my @res;

# To determine the colors, rather than breaking the md5sum into groups of 3 characters, (which leaves two lonely character at the end), I elected to replicate the first 5 characters onto the end, then for each character, used it and the 5 characters following as a true-color index. I also added an option to output as HTML code for ease of pasting in here.

unit sub MAIN ($mode = 'HTML');

my $in   = open('ref/checksumcolor.dat');
my $*OUT = 'run/checksumcolor.html'.IO.open(:w) orelse .die;

if $*OUT.t or $mode eq 'HTML' {
    say '<div style="background-color:black; font-size:125%; font-family: Monaco, monospace;">' if $mode eq 'HTML';

    while my $line = $in.get() {
        my $cs  = $line.words[0];
        my $css = $cs ~ $cs.substr(0,5);
        given $mode {
            when 'ANSI' {
                print "\e[48;5;232m";
                .print for $css.comb.rotor(6 => -5)>>.map({ ($^a, $^b).join })\
                .map( { sprintf "\e[38;2;%d;%d;%dm", |$_Â».parse-base(16) } ) Z~ $cs.comb;
                say "\e[0m {$line.words[1..*]}";
            }
            when 'HTML' {
                $*OUT.print: "$_\</span>" for $css.comb.rotor(6 => -5)\
                .map( { sprintf "<span style=\"color:#%s;\">", $_.join } ) Z~ $cs.comb;
                say " <span style=\"color:#ffffff\">{$line.words[1..*]}</span>";
                say '<br>';
            }
            default { say $line; }
        }
    }

    say '</div>' if $mode eq 'HTML';
} else {
    .say while $_ = $in.get();
}

