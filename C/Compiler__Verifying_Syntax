#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Compiler__Verifying_Syntax
#t# inprogress
#c# 2020-01-xx >RC
#m# MOAR: OK
#j# JVM:  OK
#n# note the stupid space in the URL...

# a grammar to parse EBNF
grammar EBNF {
  rule         TOP { ^ <title>? '{' [ <production> ]+ '}' <comment>? $ }
  rule  production { <name> '=' <expression> <[.;]> }
  rule  expression { <term> +% "|" }
  rule        term { <factor>+ }
  rule      factor { <group> | <repeat> | <optional> | <identifier> | <literal> }
  rule       group { '(' <expression> ')' }
  rule      repeat { '{' <expression> '}' }
  rule    optional { '[' <expression> ']' }
  token identifier { <-[\|\(\)\{\}\[\]\.\;\"\'\s]>+ } 
  token    literal { ["'" <-[']>+ "'" | '"' <-["]>+ '"'] } 
  token      title { <literal> }
  token    comment { <literal> }
  token       name { <identifier>  <?before \h* '='> }
}

class EBNF::Actions {
    method        TOP($/) { 
                            make 'grammar ' ~
                              ($<title> ?? $<title>.subst(/\W/, '', :g) !! 'unnamed') ~
                              " \{\n rule TOP \{^[<" ~ $/<production>[0]<name> ~
                              ">]+\$\}\n " ~ $<production>>>.ast ~ "\}"
                          }
    method production($/) { 
                            make 'token ' ~ $<name> ~ ' {' ~
                              $<expression>.ast ~ "}\n"
                          }
    method expression($/) { make join '|', $<term>>>.ast }
    method       term($/) { make join '\h*', $<factor>>>.ast }
    method     factor($/) { 
                            make $<literal>  ?? $<literal> !!
                              $<group>    ?? '[' ~ $<group>.ast    ~ ']'  !!
                              $<repeat>   ?? '[' ~ $<repeat>.ast   ~ '\\s*]*' !!
                              $<optional> ?? '[' ~ $<optional>.ast ~ ']?' !!
                              '<' ~ $<identifier> ~ '>'
                          }
    method     repeat($/) { make $<expression>.ast }
    method   optional($/) { make $<expression>.ast }
    method      group($/) { make $<expression>.ast }
}

# the grammar being tested
my $ebnf = q:to/END/;
"g" {
stmt         =         expr ; 

expr         =         expr_level_2; 
expr_level_2 =         expr_level_3 {"or" expr_level_3} ; 
expr_level_3 =         expr_level_4 {"and" expr_level_4} ; 
expr_level_4 = ["not"] expr_level_5 [('=' | '<') expr_level_5] ; 
expr_level_5 =         expr_level_6 {('+' | '-') expr_level_6} ; 
expr_level_6 =         primary      {('*' | '/') primary} ; 

primary      =         Identifier
                     | Integer
                     | '(' expr ')'
                     | "true"
                     | "false"
                     ;

Integer      =         Digit {Digit};

Identifier   =         Letter {Letter | Digit | '_'};

Digit        =         "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

Letter       =         "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" 
                     | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" 
                     | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" 
                     | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" 
                     | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" 
                     | "Y" | "Z" ;
}
END

my $p = EBNF.parse($ebnf, :actions(EBNF::Actions));
die "Well that didn't go well" unless $p;

my $grammar = $p.ast;
$grammar ~~ m/^'grammar '(\w+)/;
my $title = $0;
my $fn = 'VStest';
my $fh = open($fn, :w) orelse .die;
$fh.say( "\{\n", $grammar );
$fh.say(  q|CATCH { default { say " - $_" } };| );
my $s = 'i++'; #'3 + not 5';
my $len = $s.chars;
$fh.say( qq|printf "%{$len}s", '{$s}';| ~
         qq|printf " - %s\\n", {$title}.parse('{$s}')| ~
         qq| ?? 'valid.' !! 'NOT valid.';|
       );
$fh.say( qq| } |);
$fh.close;
say qqx[perl6 $fn];
unlink $fn;
