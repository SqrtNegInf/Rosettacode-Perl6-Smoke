#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Latin_Squares_in_reduced_form
#c# 2019-12-xx >RC
#m# MOAR: OK
#j#  JVM: OK
#n# not quite up to task spec. yet
#n# performance issues: fine for 4/5, but very slow for 6 (hyper and/or prune?)

my @res;

sub prefix:<!>(Int $n) { (1, 0, 1, -> $a, $b { ($++ + 2) Ã— ($b + $a) } ... *)[$n] }

sub derangements(@l) { @l.permutations.grep(-> @p { none(@p Zeqv @l) }) }

my $n = 5;
my @l = 1 X+ ^$n;

my %deran = derangements(@l).classify: *.[0], :as(*.Array);
# my %deran = derangements(@l).classify(*.[0]); # list
# my %deran = derangements(@l).classify: { .[0] }; # list
#dd %deran; exit;

# ([X] (^(!$n/($n-1))) xx $n-1).race.map: -> $tuple {
for [X] (^(!$n/($n-1))) xx $n-1 -> $tuple {
    my @candidate = @l, | map { %deran{$_}[$tuple[$_-2]] }, 2 .. $n;
    next unless [==] [Z+] @candidate; # 1st check

    my $bad = 0;
    #($bad++ if [or] (@candidate[$_]       Z== @candidate[$_+1]      )) for 0 .. $n-2; # 2nd check
    ($bad++ if [or] (@candidate[$_].Array Z== @candidate[$_+1].Array)) for 0 .. $n-2; # 2nd check
    next if $bad > 0;

    @res.push: join(' : ', @candidate);          # display as one line 
    #@res.push: join("\n", @candidate) ~ "\n";   # or as square
}

say +@res; exit;
.say for @res; exit;

my $ref = q:to/END/;
1 2 3 4
2 1 4 3
3 4 1 2
4 3 2 1

1 2 3 4
2 1 4 3
3 4 2 1
4 3 1 2

1 2 3 4
2 3 4 1
3 4 1 2
4 1 2 3

1 2 3 4
2 4 1 3
3 1 4 2
4 3 2 1
END

use Test;
is @res.join("\n"), $ref;
