#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Law_of_cosines_-_triples
#c# 2018-09-23
#m# MOAR: OK
#j#  JVM: OK 
#n# see -1 variant (that one uploaded to RC)
#n# extra credit is just toodamnslow -- how to make it fast and still keep it a general-purpose algorithm?
#n# manually verified results by printing out all 28393 triplets, and doing:
#n#   perl -a -e 'print unless $F[0]==$F[1] && $F[1]==$F[2]' <fn> | wc -l
#n# remaining .sqrt more expensive than **2, build a hash and do lookups?

my @res;

sub triples ($n, @angles) {
    my $sq-as-set = set my @squares = 1..$n X**2;
    my %triples; my %c2;
    for flat 1..$n X 1..$n -> $a, $b {
        next if $a > $b;
        my $a2 = $a**2; 
        my $b2 = $b**2;
        my $ab = $a * $b;

        # does X do the math, then throw away extra results?
        #%c2{@angles} = $a2 + $b2 X+ (-$ab, 0, $ab)[^+@angles];  # but this is slower
        %c2{@angles} = $a2 + $b2 X+ -$ab, 0, $ab; 

        %triples{$_}{~($a, $b, %c2{$_}.sqrt)}++ if %c2{$_} ∈ $sq-as-set for @angles;
    }
    %triples;
}

#my %x = triples(10000,[60]); dd %x; exit;

# 10_000 too slow, just proof-of-concept for smaller N
#for 13, 100, 500, 1000 -> $n {
for 500 -> $n {
    @res.push: "Non-equilateral n=$n/60°: " ~ [+] ([!=] .split(' ') for triples($n,[60]){60}.keys);
}

#    13     0.802u  0.115s    0:00.61
#   100     2.155u  0.148s    0:01.86
#   500    29.274u  0.202s    0:29                  19.156u 0.160s 0:18.93
#  1000   115.684u  0.449s    1:56                  79.540u 0.929s with >=
# 10000 14920.686u 99.103s 3:57:16 (non-optimized)
# 10000                    3:13:41 (optimized)

say my $result = join "\n", @res;
exit;

my $ref = qq:to/END/;
Non-equilateral n=13/60°: 2
Non-equilateral n=100/60°: 70
Non-equilateral n=500/60°: 546
Non-equilateral n=1000/60°: 1260
END
#Non-equilateral n=10000/60°: 18394

use Test; 
is $result, chomp $ref;
