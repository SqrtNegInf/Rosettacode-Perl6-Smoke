#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Law_of_cosines_-_triples
#c# 2018-09-23
#m# MOAR: OK
#j#  JVM: OK 
#n# see -1 variant (that one uploaded to RC)
#n# extra credit 10_000 is just toodamnslow
#n# manually verified results by printing out triplets:
#n#   perl -a -e 'print unless $F[0]==$F[1] && $F[1]==$F[2]' <fn> | wc -l

my @res;

sub triples ($n, @angles) {
    my $sq-as-set = set my @squares = 1..$n X**2;
    my %triples; my %c2;
    for flat @squares X @squares -> $a2, $b2 {
        next unless $b2 >= $a2;
        (my $a, my $b) = ($a2,$b2)».sqrt».floor; 
        my $ab = $a * $b;
        %c2{@angles} = $a2 + $b2 X+ -$ab, 0, $ab; 
        %triples{$_}{~($a, $b, %c2{$_}.sqrt)}++ if %c2{$_} ∈ $sq-as-set for @angles;
    }
    %triples;
}

#my %x = triples(10000,[60]); dd %x; exit;

# 10_000 too slow, just proof-of-concept for smaller N
for 13, 100, 500, 1000 -> $n {
    @res.push: "Non-equilateral n=$n/60°: " ~ [+] ([!=] .split(' ') for triples($n,[60]){60}.keys);
}

#    13     0.802u  0.115s    0:00.61
#   100     2.155u  0.148s    0:01.86
#   500    29.274u  0.202s    0:29
#  1000   115.684u  0.449s    1:56
# 10000 14920.686u 99.103s 3:57:16 (non-optimized)

say my $result = join "\n", @res;

my $ref = qq:to/END/;
Non-equilateral n=13/60°: 2
Non-equilateral n=100/60°: 70
Non-equilateral n=500/60°: 546
Non-equilateral n=1000/60°: 1260
END
#Non-equilateral n=10000/60°: 18394

use Test; 
is $result, chomp $ref;
