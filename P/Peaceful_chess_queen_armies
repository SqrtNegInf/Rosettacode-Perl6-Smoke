#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Peaceful_chess_queen_armies
#t# inprogress
#c# 2019-11-xx >RC
#m# MOAR: BROKEN
#j# JVM:  BROKEN
#n# ♛: ♕:

my ($solution); # this must remain global

my $m = 2;
my $n = 3;

my $empty-square = '◦•';

my $counter = 0;

## KLUDGE --- temporarily global for efficiency
    # logic of 'attack' regex: queen ( ... paths between queens containing only empty squares ... ) queen of other color
    my %Q = 'WBBW'.comb; # return the queen of alternate color
    my $smack = 
    '(<[WB]>)' ~
    '[' ~
       join(' |', 
         qq/<[$empty-square]>*/, 
         map { 
           qq/ . ** {$_}[<[$empty-square]> ** {$_}]*/ 
         }, $n-1, $n, $n+1
       ) ~
    ']' ~
    '<{%Q{$0}}>';
    my $attack = "rx/$smack/".EVAL;

my $board = ($empty-square x $n**2).comb.rotor($n)>>.join[^$n].join: "\n";

place($board, $n, $m, $empty-square);

say $solution 
    ?? "Solution to $m $n\n\n{$solution}" 
    !! "No solution to $m $n";

# recursively place the next queen
sub place ($board, $n, $m, $empty-square) {
    state %seen;
    state $counter;
    return if %seen{$board}++;
    # bail out if seen this configuration previously, or attack detected
say "C:{$counter++}";
say $board ~ "\n"; say $board ~~ $attack; #sleep .5;
    return if $board ~~ $attack;
    #return if %seen{$board}++ or $board ~~ $attack;

    # success if queen count is m×2
    $solution = $board and return if $m * 2 == (my $have = $board.comb.Bag{<W B>}.sum);

    # place the next queen (alternating colors each time)
    my $cnt = 0;
    while ($board ~~ m:nth(++$cnt)/<[◦•]>/) {
        say $board ~ "\n"; #sleep .5;
        place( $board.subst( /<[◦•]>/, {<W B>[$have % 2]}, :nth($cnt) ), $n, $m, $empty-square );
    }
}

my $ref = q:to/EOD/;
•B•B•
B•◦•◦
•◦W◦W
B•◦•◦
•◦W◦W
EOD

#use Test;
#is $result, chomp $ref;
