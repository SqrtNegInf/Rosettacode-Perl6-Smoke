#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Peaceful_chess_queen_armies
#c# 2019-11-xx >RC
#m# MOAR: OK
#j# JVM:  OK
#n# testing a smaller board, this is a slow algorithm with Raku
#n# wart alert: in 'place' routine using literal '◦•' in regex because I cannot figure out a
#n# way to efficiently create a regex object which is built from $empty-square

my ($solution); # this must remain global

# recursively place the next queen
sub place ($board, $n, $m, $empty-square) {
    state (%seen,$attack);

    # logic of 'attack' regex: queen ( ... paths between queens containing only empty squares ... ) queen of other color
    unless (defined $attack) {
      my %Q = 'WBBW'.comb; # return the queen of alternate color
      my $re = 
        '(<[WB]>)' ~
        '[' ~
          join(' |', 
            qq/<[$empty-square]>*/, 
            map { 
              qq/ . ** {$_}[<[$empty-square]> . ** {$_}]*/ 
            }, $n-1, $n, $n+1
          ) ~
        ']' ~
        '<{%Q{$0}}>';
      $attack = "rx/$re/".EVAL;
    }

    # bail out if seen this configuration previously, or attack detected
    return if %seen{$board}++ or $board ~~ $attack;

    # success if queen count is m×2
    $solution = $board and return if $m * 2 == (my $queens = $board.comb.Bag{<W B>}.sum);

    # place the next queen (alternating colors each time)
    my $cnt = 0;
    place( $board.subst( /<[◦•]>/, {<W B>[$queens % 2]}, :nth($cnt) ), $n, $m, $empty-square )
      while $board ~~ m:nth(++$cnt)/<[◦•]>/;
}

my $m = 2;
my $n = 4;

my $empty-square = '◦•';

my $board = ($empty-square x $n**2).comb.rotor($n)>>.join[^$n].join: "\n";

place( $board, $n, $m, $empty-square );

say $solution 
    ?? "Solution to $m $n\n\n{S:g/(\N)/$0 / with $solution}"
    !! "No solution to $m $n";

my $ref = q:to/END/;
◦B◦•
◦•◦•
B•◦•
◦•WW
END

my $ref_4x5 = q:to/EOD/;
◦B◦B◦
B◦•◦•
◦•W•W
B◦•◦•
◦•W•W
EOD

use Test;
is $solution, chomp $ref;

#`{

◦ B ◦ B ◦
B ◦ • ◦ •
◦ • W • W
B ◦ • ◦ •
◦ • W • W

}
