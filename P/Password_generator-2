#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Password_generator
#c# 2021-01-13 <RC, 2021-01-xx >RC
#m# MOAR: OK
#j#  JVM: OK
#n# 'functional' version, improved as per comments @ RC
#n# over-represents digits?  Sometimes see: Use of Nil in string context (line 25)

my @res;

my @char-groups =
        ['a' .. 'z'],
        ['A' .. 'Z'],
        ['0' .. '9'],
        < $ % & \ ` ~ ! * + , - . / :  ;  = ? @ ^ _  ~ [ ] ( ) { | } # ' " \< \> >.Array;

subset MinimumPasswordLength of  Int where * >= 4;
subset NumberOfPasswords     of UInt where * != 0;

#sub MAIN( NumberOfPasswords:D :c(:$count), MinimumPasswordLength :l(:$length) = 10,  Str :x(:$exclude) = '' )
sub MAIN( NumberOfPasswords :c(:$count) = 4, MinimumPasswordLength :l(:$length) = 13,  Str :x(:$exclude) = '' )
{
    #srand 123456; # doesn't yield stable output

    .say for password-characters($length, $exclude.comb )
        .map( *.split(' '))
        .map( *.pick: Inf ) # shuffle, so we don't get a predictable pattern
        .map( *.join )
        .head( $count );
}

#`{{
sub password-characters($length, @exclude ) {
    (
     ((    char-groups-one-of-each(@exclude) xx Inf ).map: *.pick).batch(        4)
    Z~
     (( char-groups-random-weights(@exclude) xx Inf ).map: *.pick).batch($length-4)
    )
}

sub    char-groups-one-of-each( @exclude ) { | @char-groups.map( * (-) @exclude ) }

sub char-groups-random-weights( @exclude ) { flat (map { ($_ xx ^10 .roll)}, (@char-groups.map: { ($_ (-) @exclude ) })>>.keys) }
}}

sub password-characters($length, @exclude ) {
    (
     (( char-groups(@exclude)     xx Inf ).map: *.pick).batch(        4)
    Z~
     (( char-groups(@exclude, 10) xx Inf ).map: *.pick).batch($length-4)
    )
}

multi char-groups( @exclude )              { | @char-groups.map( * (-) @exclude ) }

#multi char-groups( @exclude, $max-weight ) { flat (map { ($_ xx ^$max-weight .roll) }, char-groups(@exclude)>>.keys) }
 multi char-groups( @exclude, $max-weight ) { flat (char-groups(@exclude)>>.keys.map: {$_ xx ^$max-weight .roll}) }

#my $ref = qq:to/END/;
#END
#use Test;
#is @res.join("\n"), chomp $ref;
