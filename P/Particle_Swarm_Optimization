#!/usr/bin/env perl6
#t# inprogress
#c# 2020-01-xx >RC
#m# MOAR: OK
#j# JVM:  OK
#n# 🌐 didn't work well in variable names :-(

srand 123456;

sub report (%state) {
  say '';
  say 'Iteration: ' ~ %state{'iter'};
  say '🌐 best position: ' ~ %state{'gbpos'};
  say '🌐 best value: ' ~ %state{'gbval'};
}

sub pso-init (%y) {
    my $d = %y{'min'}.elems;
    my $n = %y{'n'};
    %y{'iter'}  = 0; 
    %y{'gbval'} = Inf; 
    %y{'gbpos'} = (Inf xx $d).Array;
    %y{'bval'}  = (Inf xx $n).Array;
    %y{'bpos'}  = (%y{'min'} xx $n).Array;
    %y{'pos'}   = (%y{'min'} xx $n).Array;
    %y{'vel'}   = ([(0) xx $d] xx $n).Array;
    %y{'d'} = $d;
    return %y;
}

sub pso (&fn, %y) {
#dd %y; sleep 100;
    my %p = %y{'parameters'};
    my $n = %y{'n'};
    my $d = %y{'min'}.elems;
    my @v = 0 xx $n;
    my @gbpos = 0 xx $d;
    my @bval  = 0 xx $n;
    my @bpos  = %y{'min'} xx $n;
dd @bpos; say '---';
    my $gbval = Inf; 
    for 0 ..^ $n -> \j {
        # evaluate
        @v[j] = &fn(|%y{'pos'}[j]);
        # update
        if @v[j] < %y{'bval'}[j] {
            @bpos[j] = %y{'pos'}[j];
            @bval[j] = @v[j];
        } else {
            @bpos[j] = %y{'bpos'}[j];
            @bval[j] = %y{'bval'}[j];
        }
        if @bval[j] < $gbval {
            $gbval = @bval[j];
            @gbpos = |@bpos[j];
        }
    }
dd @bpos; say '==='; sleep 0;
#dd @bpos; exit;
    my $rg = rand;
    my @pos = [(0) xx $d] xx $n;
    my @vel = [(0) xx $d] xx $n;
    my $iter;

    for 0 ..^ $n -> \j {
        # migrate
        my $rp = rand;
        my $ok = True;
        @vel[j] = ((0) xx @vel[j].elems).Array;
        @pos[j] = ((0) xx @pos[j].elems).Array;
#        dd ((0) xx @pos[j].elems).Array;
        for 0 ..^ $d -> \k {
                      say %p{'φ-p'}*$rp ; say (@bpos[j][k] - %y{'pos'}[j][k]); 
                      say %p{'φ-g'}*$rg;  say (@gbpos[k]   - %y{'pos'}[j][k]);
            @vel[j][k] = %p{'ω'} * %y{'vel'}[j][k] 
                      + %p{'φ-p'} * $rp * (@bpos[j][k] - %y{'pos'}[j][k]) 
                      + %p{'φ-g'} * $rg * (@gbpos[k]   - %y{'pos'}[j][k]);
            @pos[j][k] = %y{'pos'}[j][k] + @vel[j][k];
say 'vel';
dd @vel; sleep 1;
            $ok = %y{'min'}[k] < @pos[j][k] < %y{'max'}[k] if $ok;
        }
        if not $ok {
            for 0 ..^ $d -> \k {
                @pos[j][k] = %y{'min'}[k] + (%y{'max'}[k] - %y{'min'}[k]) * rand;
            }
#say 'not ok'; dd @pos;
        }
    }
    $iter = 1 + %y{'iter'};
#dd @pos ; sleep 10;
    #return State(iter, gbpos, gbval, y.min, y.max, y.parameters, pos, vel, bpos, bval, y.n, y.d);
    {iter => $iter, gbpos => @gbpos, gbval => $gbval, min => %y{min}, max => %y{max}, parameters => %y{'parameters'}, 
        pos => @pos, vel => @vel, bpos => @bpos, bval => @bval, n => $n, d => $d};
#exit;
}

sub iterate (&fn, $n, %y is copy) {
  my %old = %y;
  if $n == Inf {
    #while (%y = pso(&fn,%y)) !eqv %old { %old = %y }
  } else {
    #%y = pso(&fn, %y) for 1 .. $n;
    for 1 .. $n {
        %y = pso(&fn, %y) ;
        dd %y; sleep 30;
    }
  }
  say 'done iter';
  dd %y; sleep 30;
  %y
}

sub mccormick ($a, $b) {
#say 'a ' ~ $a; say 'b ' ~ $b;
  return sin($a+$b) + ($a-$b)**2 + (1 + 2.5*$b - 1.5*$a)
}

sub michalewicz (@x) {
    my $m = 10;
    my $d = @x.elems;
    my $sum = 0;
    for 1..$d -> $i {
        my $j = @x[$i - 1];
        my $k = sin($i * $j**2 / π);
        $sum += sin($j) * $k ** (2 * $m)
    }
    return -sum
}

# mccormick
my %state = pso-init( {
    min => [-1.5, -3], 
    max => [4, 4], 
    n=> 10,
    parameters => {ω=> 0, φ-p=> 0.6, φ-g=> 0.3},
} );

#%state = pso(&mccormick, %state);
report(%state);
%state = iterate( &mccormick, 40, %state);
report(%state);
exit;

# michalewicz 
#%state = pso-init( {
#    min => [0, 0], 
#    max => [π, π], 
#    n=> 1000,
#    parameters => {ω=> 0.3, φ-p=> 0.3, φ-g=> 0.3},
#} );
#pso(&mccormick, %state);
#report(%state);

