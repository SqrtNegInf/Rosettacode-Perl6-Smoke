#!/usr/bin/env perl6
#t# inprogress
#c# 2020-01-xx >RC
#m# MOAR: OK
#j# JVM:  OK

srand 123456;

sub report (%state) {
  say '';
  say 'Iteration: ' ~ %state{'iter'};
  say 'Global best position: ' ~ %state{'gbpos'};
  say 'Global best value: ' ~ %state{'gbval'};
}

sub pso-init (%y) {
    my $d = %y{'min'}.elems;
    my $n = %y{'n'};
    %y{'iter'}  = 0; 
    %y{'gbval'} = Inf; 
    %y{'gbpos'} = (Inf xx $d).Array;
    %y{'bval'}  = (Inf xx $n).Array;
    %y{'bpos'}  = (%y{'min'} xx $n).Array;
    %y{'pos'}   = (%y{'min'} xx $n).Array;
    %y{'vel'}   = ([(0) xx $d] xx $n).Array;
    %y{'d'} = $d;
    return %y;
}

sub pso (&fn, %y) {
#dd %y; sleep 100;
    my %p = %y{'parameters'};
    my $n = %y{'n'};
    my $d = %y{'min'}.elems;
    my @v = 0 xx $n;
    my @gbpos = 0 xx $d;
    my @bval  = 0 xx $n;
    my @bpos  = %y{'min'} xx $n;
    my $gbval = Inf; 
    for 0 ..^ $n -> \j {
        # evaluate
        @v[j] = &fn(|%y{'pos'}[j]);
        # update
        if @v[j] < %y{'bval'}[j] {
            @bpos[j] = %y{'pos'}[j];
            @bval[j] = @v[j];
        } else {
            @bpos[j] = %y{'bpos'}[j];
            @bval[j] = %y{'bval'}[j];
        }
        if @bval[j] < $gbval {
            $gbval = @bval[j];
            @gbpos = @bpos[j];
        }
    }
    my $rg = rand;
    my @pos = [(0) xx $d] xx $n;
    my @vel = [(0) xx $d] xx $n;
    my $iter;

    for 0 ..^ $n -> \j {
        # migrate
        my $rp = rand;
        my $ok = True;
        @vel[j] = ((0) xx @vel[j].elems).Array;
        @pos[j] = ((0) xx @pos[j].elems).Array;
        for 0 ..^ $d -> \k {
say 'j: ' ~ j; say 'k: ' ~ k;
            @vel[j][k] = %p{'ω'} * %y{'vel'}[j][k] 
                      + %p{'φ-p'} * $rp * (@bpos[j][k] - %y{'pos'}[j][k]) 
                      + %p{'φ-g'} * $rg * (@gbpos[k]   - %y{'pos'}[j][k]);
            @pos[j][k] = %y{'pos'}[j][k] + @vel[j][k];
dd %y{'min'}[k]; %y{'max'}[k]; #sleep 5;
            $ok = $ok and %y{'min'}[k] < @pos[j][k] and %y{'max'}[k] > @pos[j][k];
        }
        if not $ok {
            for 0 ..^ $d -> \k {
                @pos[j][k] = %y{'min'}[k] + (%y{'max'}[k] - %y{'min'}[k]) * rand;
            }
        }
    }
    $iter = 1 + %y{'iter'};
    #return State(iter, gbpos, gbval, y.min, y.max, y.parameters, pos, vel, bpos, bval, y.n, y.d);
    dd {iter => $iter, gbpos => @gbpos, gbval => $gbval, min => %y{min}, max => %y{max}, parameters => %y{'parameters'}, 
        pos => @pos, vel => @vel, bpos => @bpos, bval => @bval, n => $n, d => $d};
exit;
}

sub iterate (&fn, $n, %y) {
  my %r   = %y; 
  my %old = %y;
  if $n == Inf {
    while (%r = pso(&fn,%r)) !eqv %old { %old = %r }
  } else {
    %r = pso(&fn, %r) for 0 ..^ $n;
  }
  %r
}

sub mccormick ($a, $b) {
  return sin($a+$b) + ($a-$b)**2 + (1 + 2.5*$b - 1.5*$a)
}

sub michalewicz (@x) {
    my $m = 10;
    my $d = @x.elems;
    my $sum = 0;
    for 1..$d -> $i {
        my $j = @x[$i - 1];
        my $k = sin($i * $j**2 / π);
        $sum += sin($j) * $k ** (2 * $m)
    }
    return -sum
}

# mccormick
my %state = pso-init( {
    min => [-1.5, -3], 
    max => [4, 4], 
    n=> 3,
    parameters => {ω=> 0, φ-p=> 0.6, φ-g=> 0.3},
} );
pso(&mccormick, %state);
#%state = iterate { return pso(mccormick,y) }, 40, %state);
report(%state);

# michalewicz 
#%state = pso-init( {
#    min => [0, 0], 
#    max => [π, π], 
#    n=> 1000,
#    parameters => {ω=> 0.3, φ-p=> 0.3, φ-g=> 0.3},
#} );
#pso(&mccormick, %state);
#report(%state);

