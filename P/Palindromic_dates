#!/usr/bin/env perl6
#c#  2019-09-13 NOT ON RC
#m# MOAR: OK
#j# JVM:  BROKEN
#n# WIP, this is not the final word
#n# Julian/Gregorian missing days (Oct 4, 1582, Sep 2, 1752) not potential palindromes

my @res;

#use Sort::Naturally;
use Lingua::EN::Numbers::Ordinate:from<Perl5>;

enum months_with_30_days (Apr => 4, Jun => 6, Sep => 9, Nov => 11);
sub is-leap-year { !(@_[0] % 100) ?? !(@_[0] % 400) !! !(@_[0] % 4) }

sub find-palindromes ($format is copy = 'MM-DD-YYYY', $last-year is copy = 9999) {
    my ($i,@range,%palindromes,%time-span);

    $format .= uc;
    my $separator = $format.match(/<-[YMD]>/) || '-';
    $format .= subst(/<-[YMD]>/, '', :g);
    $last-year = 99 if 2 == .chars given $format ~~ /(Y+)/; # make executive decision to avoid duplicative results

    for $format.comb: /(.) $0*/ -> $time-unit {
        $i++;
        my $len = $time-unit.chars;
        my $fmt = '%' ~ ('0' if $len>1) ~ $len ~ 'd';
        given $time-unit {
            when /D/ { 
                %time-span{'D'} = $i-1;
                @range[$i].push: sprintf $fmt, $_ for 1..31 }
            when /M/ { 
                %time-span{'M'} = $i-1;
                @range[$i].push: sprintf $fmt, $_ for 1..12 }
            when /Y/ { 
                %time-span{'Y'} = $i-1;
                @range[$i].push: sprintf $fmt, $_ for 0..$last-year }
            default { 
                die "Does anybody really understand time?" 
            }
        }
    }

    for @(@range[1]) X @(@range[2]) X @(@range[3]) -> $date-triple {
#    (@(@range[1]) X @(@range[2]) X @(@range[3])).race.map: -> $date-triple {
        next unless $_ eq .flip given join '', @$date-triple;

        my ($d) = @$date-triple[%time-span{'D'}]; 
        my ($m) = @$date-triple[%time-span{'M'}]; 
        my ($y) = @$date-triple[%time-span{'Y'}];
        next if $m == 2 and ($d > 29 || $d == 29 && !is-leap-year($y)); # for 'yy' format, treated as 1st century
        next if $d == 31 and $m == any(Apr,Jun,Sep,Nov);

        %palindromes{ join $separator, @$date-triple } = $y ~ $m ~ $d;
    }

    %palindromes.sort(*.value)>>.key;
}

#my @y-m-d = find-palindromes('y-m-d', 9999); 
#say "Using 'Y-M-D' format, {+@y-m-d} palindromes over 10,000 years.";
#.say for @y-m-d;
#exit;

my @m-d-yy = grep { $_.subst(/<-[0..9]>/, '', :g) ~~ /^ (<[0..9]>) $0* $/ }, find-palindromes('MDYY'); 
@res.push: "Using 'M-D-YY' format, there are {+@m-d-yy} palindromic dates in a century that use only one digit:";
@res.push: join ', ', @m-d-yy;
@res.push: '';

my %centuries;
%centuries{+$_}++ for map { substr $_, 6, 2 }, find-palindromes('mm/dd/yyyy',2099); 
@res.push: "Using 'MM/DD/YYYY' format, the distribution of palindromic dates up through the 21st century:";
@res.push: sprintf "%3d in the %4s century", %centuries{$_}, ordinate($_+1)
    for %centuries.keys.sort({$^a <=> $^b});
@res[*-1] ~= "\n";

.say for @res;

my $ref = q:to/END/;
Using 'M-D-YY' format, there are 13 palindromic dates in a century that use only one digit:
1-1-11, 1-11-11, 11-1-11, 11-11-11, 2-2-22, 2-22-22, 3-3-33, 4-4-44, 5-5-55, 6-6-66, 7-7-77, 8-8-88, 9-9-99

Using 'MM/DD/YYYY' format, the distribution of palindromic dates up through the 21st century:
 12 in the  2nd century
 12 in the  3rd century
 11 in the  4th century
 12 in the 11th century
 12 in the 12th century
 12 in the 13th century
  7 in the 14th century
 12 in the 21st century
END

use Test;
is @res.join("\n"), $ref;
