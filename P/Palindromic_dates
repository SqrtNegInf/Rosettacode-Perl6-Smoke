#!/usr/bin/env perl6
## xxx
#  David H.  2019-09-12
#n# fundamentally simple task used to show off how nice Perl 6 makes life for a programmer (Hi Oscar!)
#n# notes:
#n# fortunately 2-29-22 is not a leap year ('yy' ambiguous)
#n# slow, but the results are good for 100,000 years!
#n# not using any date/time facility in the language (though might be good to validate dates?)

my @res;

srand 1;

use Lingua::EN::Numbers::Ordinate:from<Perl5>;

enum months_with_30_days (Apr => 4, Jun => 6, Sep => 9, Nov => 11);
sub is-leap-year { !(@_[0] % 100) ?? !(@_[0] % 400) !! !(@_[0] % 4) }

sub find-palindromes ($format is copy = 'MM-DD-YYYY', $first-year = 0, $last-year is copy = 9999, :$pairs = False) {
    my ($i,@range,%palindromes,%time-span);

    $format .= uc;
    my $separator = $format.match(/<-[YMD]>/) || '-';
    $format .= subst(/<-[YMD]>/, '', :g);
    $last-year = 99 if 2 == .chars given $format ~~ /(Y+)/; # make executive decision to avoid duplicative results

    for $format.comb: /(.) $0*/ -> $time-unit {
        my $len = $time-unit.chars;
        my $fmt = '%' ~ ('0' if $len>1) ~ $len ~ 'd';
        given $time-unit {
            when /D/ { %time-span{'d'} = ++$i-1; @range[$i].push: sprintf $fmt, $_ for 1..31 }
            when /M/ { %time-span{'m'} = ++$i-1; @range[$i].push: sprintf $fmt, $_ for 1..12 }
            when /Y/ { %time-span{'y'} = ++$i-1; @range[$i].push: sprintf $fmt, $_ for $first-year .. $last-year }
            default  { die "Does anybody really understand time?" }
        }
    }

#    for @(@range[1]) X @(@range[2]) X @(@range[3]) -> $date-triple {
    (@(@range[1]) X @(@range[2]) X @(@range[3])).race.map: -> $date-triple {
        next unless $_ eq .flip given join '', @$date-triple;

        my ($d) = @$date-triple[%time-span{'d'}]; 
        my ($m) = @$date-triple[%time-span{'m'}]; 
        my ($y) = @$date-triple[%time-span{'y'}];
        next if $m == 2 and ($d > 29 || $d == 29 && !is-leap-year($y));
        next if $d == 31 and $m == any(Apr,Jun,Sep,Nov);

        %palindromes{ sprintf '%0' ~ $last-year.chars ~ 'd%02d%02d', $y, $m, $d } = join $separator, @$date-triple;
    }

    # return date pairs (canonical => formatted) or just formatted date
    flat $pairs ?? %palindromes.sort».kv !! %palindromes.sort».values;
}

say '0 <==';
my $date-format = 'M-D-YY';
my @m-d-yy = grep { $_.subst(/<-[0..9]>/, '', :g) ~~ /^ (<[0..9]>) $0* $/ }, find-palindromes($date-format);
@res.push: "Using '{$date-format}' format, there are {+@m-d-yy} palindromic dates in a century that use only one digit:";
@res.push: join(', ', @m-d-yy) ~ "\n";
say '1 <==';

$date-format = 'MM.DD.YYYY';
my %century;
%century{+$_}++ for map { substr $_, 6, 2 }, find-palindromes($date-format,1,2099); 
@res.push: "Using '{$date-format}' format, the distribution of palindromic dates for the 1st through 21st century:";
@res.push: join("\n", (sprintf "%3d in the %4s century", %century{$_}, ordinate($_+1) for %century.keys.sort: +*)) ~ "\n";
#@res.push: sprintf "%3d in the %4s century", %century{$_}, ordinate($_+1) for %century.keys.sort({$^a <=> $^b});
#@res[*-1] ~= "\n"; # wart, only in smoking test system
say '2 <==';

$date-format = 'yyyy/mm/dd';
my (@far-future-non-prime,@far-future-prime);
for find-palindromes($date-format, my $begin = 10001, my $end = 99999, :pairs<True>) -> $k, $v {
    $k.is-prime ?? @far-future-prime.push: $k => $v !! @far-future-non-prime.push: $k => $v
}
@res.push: "Using '{$date-format}' format, in the years {$begin} to {$end}, there are:";
@res.push: sprintf "%8d non-prime dates (%s ... %s)", +@far-future-non-prime, @far-future-non-prime[0,*-1]».value;
@res.push: sprintf "%8d     prime dates (%s ... %s)",     +@far-future-prime,     @far-future-prime[0,*-1]».value;
@res.push: "\nA random selection of the prime palindromic dates:";
@res.push: @far-future-prime.pick(20).sort».values.rotor(5)».fmt('%12s').join: "\n";
say '3 <==';

.say for @res;
say '4 <==';
exit;

my $ref = q:to/END/;
Using 'M-D-YY' format, there are 13 palindromic dates in a century that use only one digit:
1-1-11, 1-11-11, 11-1-11, 11-11-11, 2-2-22, 2-22-22, 3-3-33, 4-4-44, 5-5-55, 6-6-66, 7-7-77, 8-8-88, 9-9-99

Using 'MM.DD.YYYY' format, the distribution of palindromic dates for the 1st through 21st century:
 12 in the  2nd century
 12 in the  3rd century
 11 in the  4th century
 12 in the 11th century
 12 in the 12th century
 12 in the 13th century
  7 in the 14th century
 12 in the 21st century

Using 'yyyy/mm/dd' format, in the years 10001 to 99999, there are:
    3105 non-prime dates (10010/10/01 ... 92909/09/29)
     197     prime dates (10011/10/01 ... 92802/08/29)

A random selection of the prime palindromic dates:
 10013/10/01  10103/01/01  11102/01/11  11107/01/11  11216/12/11
 11600/06/11  12108/01/21  13219/12/31  30405/04/03  31600/06/13
 32208/02/23  71102/01/17  71301/03/17  71404/04/17  72108/01/27
 90106/01/09  90907/09/09  91109/01/19  91802/08/19  92011/10/29
END

use Test;
is @res.join("\n"), $ref;
say '5 <==';
