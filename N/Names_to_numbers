#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Names_to_numbers
#t# inprogress
#c# 2019-11-25 >RC
#p# OK

my @res;

my $test-data = q:to/END/;
# For numbers between 21 and 99 inclusive, we're supposed to use a hyphen,
# but the bank still cashes our check without the hyphen:
Seventy-two dollars
Seventy two dollars

# For numbers bigger than 100, we're not supposed to use "and,"
# except we still use "and" anyway, e.g.,
One Hundred and One Dalmatians
A Hundred and One Dalmatians
One Hundred One Dalmatians
Hundred and One Dalmatians
One Thousand and One Nights
Two Thousand and One: A Space Odyssey

# Date anomolies
Twenty Thirteen
Nineteen Eighty-Four

four billion, two hundred ninety-four million, nine hundred sixty-seven thousand, two hundred ninety five
Ninety-Nine Trillion Nine Hundred Ninety-Nine Billion Nine Hundred Ninety-Nine Million Nine Hundred Ninety-Nine Thousand Nine Hundred Ninety-Nine
Nine quadrillion, seven trillion, one hundred ninety-nine billion, two hundred fifty-four million, seven hundred forty thousand, nine hundred ninety two

Nine Hundred Ninety-Nine
One Thousand One Hundred Eleven
Eleven Hundred Eleven
Eight Thousand Eight Hundred Eighty-Eight
Eighty-Eight Hundred Eighty-Eight
Seven Million Seven Hundred Seventy-Seven Thousand Seven Hundred Seventy-Seven

ninety-nine
three hundred
three hundred and ten
one thousand, five hundred and one
twelve thousand, six hundred and nine
five hundred and twelve thousand, six hundred and nine
two billion, one hundred

zero
eight
one hundred
one hundred twenty three
one thousand one
ninety nine thousand nine hundred ninety nine
one hundred thousand
one hundred eleven billion one hundred eleven
END

my %nums = (
    zero        => 0,     one        => 1,     two         => 2,     three    => 3,
    four        => 4,     five       => 5,     six         => 6,     seven    => 7,
    eight       => 8,     nine       => 9,     ten         => 10,    eleven   => 11,
    twelve      => 12,    thirteen   => 13,    fourteen    => 14,    fifteen  => 15,
    sixteen     => 16,    seventeen  => 17,    eighteen    => 18,    nineteen => 19,
    twenty      => 20,    thirty     => 30,    forty       => 40,    fifty    => 50,
    sixty       => 60,    seventy    => 70,    eighty      => 80,    ninety   => 90,
    hundred     => 100,   thousand   => 1_000, million     => 1_000_000,
    billion     => 1_000_000_000,              trillion    => 1_000_000_000_000,
    quadrillion => 1_000_000_000_000_000,      quintillion => 1_000_000_000_000_000_000
);

# Groupings for thousands, millions, billions, trillions #..., quintillions
my token groups { \d**4 | \d**7 | \d**10 | \d**13 | \d**16 | \d**19 }; 

for $test-data.split("\n") -> $orig {
    next if $orig ~~ /^^ ( \s* $ || \s* '#' ) /;

    my $str = $orig.lc;
    $str ~~ s:g/'-'/ /;
    $str ~~ s:g/\s+/ /;
    $str .=trim;

    # tokenize sentence boundaries, other punctuation and symbols
    $str ~~ s:g/(<[.?!]>) / $0\n/;
    $str ~~ s:g/(<[.?!]>)$/ $0\n/;
    $str ~~ s:g/\$(.)/\$ $0/;            # prefix
    $str ~~ s:g/(.)(<[;:%',]>)/$0 $1/;   # suffix

    #$str ~~ s:g/ <|w> $_ <|w> / %nums{$_} / for %nums.keys; # ??
    for (keys %nums) -> $key { $str ~~ s:g/ <|w> $key <|w> / %nums{$key} / }

     $str ~~ s:g/(\d) \s+ ',' \s+ (\d)/$0 $1/;
     $str ~~ s:g/(\d) \s+ 'and' \s+ (\d)/$0 $1/;


    $str ~~ s:g/ <|w> (\d) \s+ '100' \s+ (\d\d) \s+ (\d) \s+ (<groups>) <|w>/{($0 * 100 + $1 + $2) * $3}/;

    $str ~~ s:g/ <|w> (\d) \s+ 100 \s+ (\d\d) \s+ (<groups>) <|w> /{($0 * 100 + $1) * $2}/;
    $str ~~ s:g/ <|w> (\d) \s+ 100 \s+ (\d) \s+ (<groups>) <|w> /{($0 * 100 + $1) * $2}/;
    $str ~~ s:g/ <|w> (\d) \s+ 100 \s+ (<groups>) <|w> /{$0 * $1 * 100}/;

    $str ~~ s:g/ <|w> \s+ 100 \s+ (\d\d) \s+ (\d) \s+ (<groups>) <|w> /{(100 + $0 + $1) * $2}/;
    $str ~~ s:g/ <|w> \s+ 100 \s+ (\d\d) \s+ (<groups>) <|w> /{(100 + $0) * $1}/;
    $str ~~ s:g/ <|w> \s+ 100 \s+ (\d) \s+ (<groups>) <|w> /{(100 + $0) * $1}/;
    $str ~~ s:g/ <|w> \s+ 100 \s+ (<groups>) <|w> /{$0 * 100}/;

    $str ~~ s:g/ <|w> (\d\d) \s+ (\d) \s+ (<groups>) <|w> /{($0 + $1) * $2}/;
#say 'sofar: ' ~ $str; sleep 10;
    $str ~~ s:g/ <|w> (\d ** 1..2) \s+ (<groups>) <|w> /{$0 * $1}/;

    $str ~~ s:g/ <|w> (\d\d) \s+ (\d) \s+ 100 \s* <|w> /{($0 + $1) * 100}/;
    $str ~~ s:g/ <|w> (\d ** 1..2) \s+ 100 \s* <|w> /{$0 * 100} /;

    # Date anomolies: nineteen eighty-four and twenty thirteen
    $str ~~ s:g/ <|w> (\d ** 2) \s+ (\d ** 2) <|w> /{$0 * 100 + $1}/;

    $str ~~ s:g/([\d+\s+]*\d+)/{[+] $0.split: ' '}/;

    say "{$orig} ==> {$str}";
    #sleep 1;
}

my $ref = q:to/END/;
END

#use Test;
#is @res.join("\n"), chomp $ref;
