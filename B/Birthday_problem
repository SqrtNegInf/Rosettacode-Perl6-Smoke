#!/usr/bin/env perl6
#u# http://rosettacode.org/wiki/Birthday_problem
#t# skiptest
#c# 2016-08-03 <RC
#m# MOAR: OK
#j#  JVM: OK
#n# current approach is to repeatedly 'roll' out groups of birthdays (a memory hog, and too slow to be useful)
#n# would it be faster to build a 'population' and sample it?  code everything into bit-fields?

srand 123456;

my @res;

sub simulation($c) {
my $max-trials = 250_000;
my $min-trials =   2_500;

my $n = floor 47 * ($c-1.5)**1.5; # OEIS/A050256: 16 86 185 307
my $N = min $max-trials, max $min-trials, 1000 * sqrt $n;

say "starting with n = $n and N = $N"; # debug

loop {
    # race - no benefit
    #my $p = $N R/ elems ((grep { $_>=$c }, values bag (^365).roll($n)) xx $N).race.grep( *.elems > 0);
    my $p = $N R/ elems grep { .elems > 0 }, ((grep { $_>=$c }, values bag (^365).roll($n)) xx $N);

    return($n, $p) if $p > 0.5;

    $N = min $max-trials, max $min-trials, floor 1000/(0.5-$p)**1.25;
    say "n: $n  p: $p  next N: $N"; # debug
    $n++;
}

}

printf "$_ people in a group of %s share a common birthday. (%.3f)\n", simulation($_) for 5..5; exit; # debug

@res.push: "$_ people in a group of %s share a common birthday. (%.3f)", simulation($_) for 2..5;

#`{{
# early exit when $p2 completes, why?
# still doesn't address the fundamental non-performant code
    my (@c2, @c3, @c4, @c5);
    my $p2 = Promise.start( { @c2.push: simulation(2) } );
    my $p3 = Promise.start( { @c3.push: simulation(3) } );
    my $p4 = Promise.start( { @c4.push: simulation(4) } );
#   my $p5 = Promise.start( { @c5 = simulation(5) } );
    await $p2, $p3, $p4; # $p5;
    say join ' ', @c2, @c3, @c4, @c5;
}}

.say for @res;

my $ref = qq:to/END/;
2 people in a group of 23 share a common birthday. (0.506)
3 people in a group of 88 share a common birthday. (0.511)
4 people in a group of 187 share a common birthday. (0.503)
5 people in a group of 314 share a common birthday. (0.xxx)
END

use Test;
is @res.join("\n"), chomp $ref;
